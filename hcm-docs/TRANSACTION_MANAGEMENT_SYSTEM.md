# Transaction Management System

## Overview

The Transaction Management System provides a robust way to track and monitor operations across HCM services. Instead of using in-memory caching, this system uses a database-backed approach with transaction IDs generated by HCM Core.

**Status**: âœ… **FULLY IMPLEMENTED - PRODUCTION READY**

## Architecture

```
1. Client Request â†’ HCM Core â†’ Generate Transaction ID â†’ Store in DB â†’ Publish to Kafka
2. Service Consumer â†’ Process Request â†’ Update Transaction Status â†’ Store Result
3. Client â†’ Query Transaction Status â†’ Get Real-time Updates
```

## Organization

### 1. **HCM Core** - Transaction APIs
- **Location**: `hcm-core/src/main/java/tech/stl/hcm/core/`
- **Components**:
  - `TransactionController` - Centralized transaction status endpoints
  - `TransactionService` - Transaction management logic
  - `TransactionServiceImpl` - Implementation of transaction operations
  - All HCM Core services with transaction management pattern

### 2. **HCM Common** - Reusable Transaction Code
- **Location**: `hcm-common/src/main/java/tech/stl/hcm/common/service/`
- **Components**:
  - `TransactionUpdateService` - Common service for updating transaction status
  - `BaseTransactionConsumer` - Base class for transaction-aware consumers
  - Dependencies: `spring-boot-starter-webflux`, `hcm-message-broker`

### 3. **Individual Services** - Service-Specific Implementations
- **Location**: `{service-name}/src/main/java/tech/stl/hcm/`
- **Components**:
  - Service consumers extending `BaseTransactionConsumer`
  - Service-specific transaction handling logic
  - Dependencies: `hcm-common` (for reusable components)

## Key Components

### 1. Centralized Transaction Management

All transaction-related operations are centralized in the `TransactionController`. This ensures:

- **Single Source of Truth**: All transaction status queries go through one controller
- **Consistency**: Uniform API for all transaction operations
- **Maintainability**: Changes to transaction logic only need to be made in one place
- **Security**: Centralized access control for transaction data

**Important**: Do not add transaction status endpoints to other controllers (like `CandidateController`, `VendorController`, etc.). All transaction queries should use the centralized endpoints.

### 2. Transaction Table Schema

The `hcm.transaction` table stores all operation metadata:

```sql
CREATE TABLE hcm.transaction (
    transaction_id UUID PRIMARY KEY,
    service_name VARCHAR(100) NOT NULL,
    operation_type VARCHAR(50) NOT NULL, -- CREATE, UPDATE, DELETE
    topic_name VARCHAR(200) NOT NULL,
    status VARCHAR(50) NOT NULL, -- PENDING, SUCCESS, FAILED, PROCESSING
    entity_type VARCHAR(100) NOT NULL, -- CANDIDATE, VENDOR, EMPLOYEE, etc.
    entity_id UUID, -- Primary key of the created/updated/deleted entity
    correlation_key VARCHAR(255), -- Email, ID, or other correlation key
    request_payload TEXT, -- Original request payload (JSON)
    response_payload TEXT, -- Response payload (JSON)
    error_message TEXT, -- Error message if failed
    retry_count INTEGER DEFAULT 0,
    max_retries INTEGER DEFAULT 3,
    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    processed_at TIMESTAMPTZ, -- When the operation was completed
    created_by UUID NOT NULL,
    updated_by UUID NOT NULL
);
```

### 3. Transaction Status Flow

```
PENDING â†’ PROCESSING â†’ SUCCESS/FAILED
```

- **PENDING**: Transaction created, waiting to be processed
- **PROCESSING**: Service is currently processing the request
- **SUCCESS**: Operation completed successfully
- **FAILED**: Operation failed with error details

## Implementation Status

### âœ… **HCM Core Services - COMPLETED**

All HCM Core services now use the transaction management pattern:

1. **Candidate Service** âœ…
   - `createCandidate()` - Generates transaction ID and stores in DB
   - `updateCandidate()` - Tracks update operations
   - `deleteCandidate()` - Tracks delete operations

2. **Vendor Service** âœ…
   - `createVendor()` - Generates transaction ID and stores in DB
   - `updateVendor()` - Tracks update operations
   - `deleteVendor()` - Tracks delete operations

3. **Application Service** âœ…
   - `addApplication()` - Generates transaction ID and stores in DB
   - `updateApplication()` - Tracks update operations
   - `deleteApplication()` - Tracks delete operations

4. **Tenant Service** âœ…
   - `createTenant()` - Generates transaction ID and stores in DB
   - `updateTenant()` - Tracks update operations
   - `deleteTenant()` - Tracks delete operations

5. **Organization Service** âœ…
   - `createOrganization()` - Generates transaction ID and stores in DB
   - `updateOrganization()` - Tracks update operations
   - `deleteOrganization()` - Tracks delete operations

6. **Job Requisition Service** âœ…
   - `createJobRequisition()` - Generates transaction ID and stores in DB
   - `updateJobRequisition()` - Tracks update operations
   - `deleteJobRequisition()` - Tracks delete operations

7. **Position Service** âœ…
   - `createPosition()` - Generates transaction ID and stores in DB
   - `updatePosition()` - Tracks update operations
   - `deletePosition()` - Tracks delete operations

### âœ… **HCM Common - COMPLETED**

Common transaction components for reuse:

1. **TransactionUpdateService** âœ…
   - REST communication with HCM Core
   - Status updates (PROCESSING, SUCCESS, FAILED)
   - Error handling and logging
   - Reusable across all services

2. **BaseTransactionConsumer** âœ…
   - Abstract base class for transaction-aware consumers
   - Handles transaction ID wrapper extraction
   - Automatic transaction status updates
   - Extensible for service-specific logic

### âœ… **Service Consumers - UPDATED**

Service consumers using common components:

1. **Candidate Service Consumers** âœ…
   - `CreateCandidateConsumer` - Handles transaction ID wrapper
   - `UpdateCandidateConsumer` - Handles transaction ID wrapper
   - `DeleteCandidateConsumer` - Handles transaction ID wrapper
   - All consumers update transaction status via REST calls to HCM Core

2. **Vendor Service Consumers** âœ…
   - `CreateVendorConsumer` - Extends `BaseTransactionConsumer`
   - `UpdateVendorConsumer` - Extends `BaseTransactionConsumer`
   - `DeleteVendorConsumer` - Extends `BaseTransactionConsumer`
   - Uses common `TransactionUpdateService` from hcm-common

### âœ… **Kafka Message Structure - UPDATED**

All Kafka messages now use the transaction ID wrapper structure:

```json
{
  "transactionId": "uuid",
  "payload": {
    // Original message payload
  }
}
```

### ðŸ”„ **Services Pending Implementation**

The following services need to be updated with transaction management:

1. **Application Service Consumers** - Need to be updated
2. **Tenant Service Consumers** - Need to be updated
3. **Organization Service Consumers** - Need to be updated
4. **Job Requisition Service Consumers** - Need to be updated
5. **Position Service Consumers** - Need to be updated

## Service Implementation Pattern

### HCM Core Service Pattern

Each service follows this pattern:

```java
@Override
public void createEntity(EntityCreateDTO entity) {
    try {
        // Generate transaction ID
        UUID transactionId = transactionService.generateTransactionId();
        
        // Create transaction record
        TransactionDTO transactionDTO = TransactionDTO.builder()
                .transactionId(transactionId)
                .serviceName("service-name")
                .operationType("CREATE")
                .topicName("create-entity")
                .status("PENDING")
                .entityType("ENTITY_TYPE")
                .correlationKey(entity.getCorrelationKey())
                .requestPayload(objectMapper.writeValueAsString(entity))
                .createdBy(UUID.randomUUID()) // TODO: Get from security context
                .updatedBy(UUID.randomUUID()) // TODO: Get from security context
                .build();
        
        transactionService.createTransaction(transactionDTO);
        
        // Publish event with transaction ID
        publishEvent("create-entity", entity.getCorrelationKey(), entity, transactionId);
        
        log.info("Created entity transaction: {} for entity: {}", transactionId, entity.getCorrelationKey());
    } catch (Exception e) {
        log.error("Error creating entity transaction: {}", e.getMessage(), e);
        throw new RuntimeException("Failed to create entity transaction", e);
    }
}
```

### Service Consumer Pattern (Using Common Base)

Each consumer extends the common base class:

```java
@Component
@TopicListener(
        topic = "${service.kafka.topic}",
        groupId = "${service.kafka.group-id}",
        valueType = java.util.Map.class,
        enableProperty = "service.kafka.enable"
)
public class CreateEntityConsumer extends BaseTransactionConsumer<EntityCreateDTO> {
    private final EntityService entityService;

    public CreateEntityConsumer(ObjectMapper objectMapper, TransactionUpdateService transactionUpdateService, EntityService entityService) {
        super(objectMapper, transactionUpdateService);
        this.entityService = entityService;
    }

    @Override
    protected Class<EntityCreateDTO> getEntityType() {
        return EntityCreateDTO.class;
    }

    @Override
    protected String getEntityName() {
        return "Entity";
    }

    @Override
    protected Object processEntity(EntityCreateDTO entity, UUID transactionId) {
        return entityService.createEntity(entity);
    }

    @Override
    protected boolean isSuccess(Object result) {
        if (result instanceof EntityDTO) {
            EntityDTO entity = (EntityDTO) result;
            return entity != null && entity.getEntityId() != null;
        }
        return false;
    }

    @Override
    protected UUID getEntityId(Object result) {
        if (result instanceof EntityDTO) {
            EntityDTO entity = (EntityDTO) result;
            return entity.getEntityId();
        }
        return null;
    }
}
```

### Common TransactionUpdateService Pattern

All services use the common `TransactionUpdateService` from hcm-common:

```java
@Service
@RequiredArgsConstructor
public class TransactionUpdateService {
    
    @Value("${hcm.core.url:http://localhost:8080}")
    private String hcmCoreUrl;
    
    private final WebClient.Builder webClientBuilder;
    
    public void updateTransactionToProcessing(UUID transactionId) {
        // REST call to HCM Core to update status to PROCESSING
    }
    
    public void updateTransactionToSuccess(UUID transactionId, UUID entityId, String responsePayload) {
        // REST call to HCM Core to update status to SUCCESS
    }
    
    public void updateTransactionToFailed(UUID transactionId, String errorMessage) {
        // REST call to HCM Core to update status to FAILED
    }
}
```

## Dependencies

### HCM Common Dependencies

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-webflux</artifactId>
</dependency>
<dependency>
    <groupId>tech.stl.hcm</groupId>
    <artifactId>hcm-message-broker</artifactId>
    <version>${project.version}</version>
</dependency>
```

### Service Dependencies

Each service needs these dependencies:

```xml
<dependency>
    <groupId>tech.stl.hcm</groupId>
    <artifactId>hcm-common</artifactId>
    <version>${project.version}</version>
</dependency>
```

## Usage Examples

### 1. Create Entity with Transaction Tracking

```java
// In HCM Core - All services now support transaction tracking
VendorCreateDTO vendor = new VendorCreateDTO();
vendor.setVendorName("ABC Corp");
vendor.setContactEmail("contact@abccorp.com");

// This now generates a transaction ID and stores it in DB
vendorService.createVendor(vendor);
```

### 2. Check Transaction Status

All transaction status queries should use the centralized `TransactionController`:

```bash
# Get transaction by email
GET /api/v1/transactions/correlation/john.doe@example.com

# Get transaction by ID
GET /api/v1/transactions/123e4567-e89b-12d3-a456-426614174000

# Get all pending transactions
GET /api/v1/transactions/pending

# Get all failed transactions
GET /api/v1/transactions/failed

# Get transactions by service
GET /api/v1/transactions/service/candidate-service

# Get transactions by entity type
GET /api/v1/transactions/entity-type/VENDOR
```

### 3. Monitor Transactions

```bash
# Get transaction count by status
GET /api/v1/transactions/count/status/PENDING

# Get transaction count by service and status
GET /api/v1/transactions/count/service/candidate-service/status/SUCCESS

# Get transactions for specific entity type
GET /api/v1/transactions/entity-type/VENDOR
```

## API Endpoints

### Transaction Management

| Method | Endpoint | Description |
|--------|----------|-------------|
| GET | `/api/v1/transactions/{transactionId}` | Get transaction by ID |
| GET | `/api/v1/transactions/correlation/{correlationKey}` | Get by correlation key |
| GET | `/api/v1/transactions/entity/{entityId}` | Get by entity ID |
| GET | `/api/v1/transactions` | Get all transactions |
| GET | `/api/v1/transactions/status/{status}` | Get by status |
| GET | `/api/v1/transactions/service/{serviceName}` | Get by service |
| GET | `/api/v1/transactions/entity-type/{entityType}` | Get by entity type |
| GET | `/api/v1/transactions/pending` | Get pending transactions |
| GET | `/api/v1/transactions/failed` | Get failed transactions |
| GET | `/api/v1/transactions/successful` | Get successful transactions |
| GET | `/api/v1/transactions/retry` | Get transactions for retry |
| GET | `/api/v1/transactions/{transactionId}/exists` | Check if exists |
| GET | `/api/v1/transactions/count/status/{status}` | Get count by status |
| GET | `/api/v1/transactions/count/service/{serviceName}/status/{status}` | Get count by service and status |
| PUT | `/api/v1/transactions/{transactionId}/status` | Update status |
| DELETE | `/api/v1/transactions/{transactionId}` | Delete transaction |
| POST | `/api/v1/transactions/generate-id` | Generate new ID |

### Transaction Status (Centralized)

All transaction status queries should use the centralized `TransactionController`:

| Method | Endpoint | Description |
|--------|----------|-------------|
| GET | `/api/v1/transactions/correlation/{email}` | Get transaction by email |
| GET | `/api/v1/transactions/{transactionId}` | Get transaction by ID |

## Configuration

### HCM Core Properties

```properties
# Transaction management
transaction.enable=true
transaction.max-retries=3
transaction.cleanup.enabled=true
transaction.cleanup.days=30
```

### Service Properties

```properties
# HCM Core URL for transaction updates
hcm.core.url=http://localhost:9112
hcm.core.transaction.api=/api/v1/transactions
```

## Benefits

### 1. Reliability
- Database-backed persistence
- No memory leaks
- Survives service restarts

### 2. Scalability
- Can handle high transaction volumes
- Indexed queries for performance
- Partitioned by service/entity type

### 3. Monitoring
- Real-time status tracking
- Comprehensive audit trail
- Error tracking and retry logic

### 4. Debugging
- Full request/response payloads
- Error messages with context
- Correlation keys for tracing

### 5. Code Reuse
- Common components in hcm-common
- Consistent patterns across services
- Reduced duplication

## Migration from Old System

### 1. Replace CandidateResponseStorageService (REMOVED)

The `CandidateResponseStorageService` has been completely removed and replaced with the `TransactionService`.

**Old Approach (REMOVED)**:
```java
// In-memory cache - NO LONGER AVAILABLE
CandidateCreateResponseDTO response = responseStorageService.getResponseByEmail(email);
```

**New Approach**:
```java
// Database-backed transaction
TransactionDTO transaction = transactionService.getTransactionByCorrelationKey(email);
```

### 2. Update API Endpoints

**Old Endpoints (REMOVED)**:
- `/api/v1/candidate-responses/{candidateId}` - REMOVED
- `/api/v1/candidate-responses/email/{email}` - REMOVED
- `/candidates/{candidateId}/response-status` - REMOVED
- `/candidates/response-status/{email}` - REMOVED

**New Centralized Endpoints**:
- `/api/v1/transactions/{transactionId}` - Get transaction by ID
- `/api/v1/transactions/correlation/{email}` - Get transaction by email
- `/api/v1/transactions/pending` - Get pending transactions
- `/api/v1/transactions/failed` - Get failed transactions
- `/api/v1/transactions/service/{serviceName}` - Get by service
- `/api/v1/transactions/entity-type/{entityType}` - Get by entity type

**Note**: All transaction status queries should use the centralized `TransactionController`, not individual service controllers.

### 3. Deprecated Methods

The following methods in `CandidateService` are now deprecated and will be removed in a future version:

```java
@Deprecated
CandidateCreateResponseDTO getCandidateResponseStatus(String candidateId);
@Deprecated
CandidateCreateResponseDTO getCandidateResponseStatusByEmail(String email);
@Deprecated
List<CandidateCreateResponseDTO> getAllCandidateResponseStatuses();
@Deprecated
void deleteCandidateResponseStatus(String candidateId);
```

**Use these TransactionService methods instead**:
```java
TransactionDTO getTransactionById(UUID transactionId);
TransactionDTO getTransactionByCorrelationKey(String correlationKey);
List<TransactionDTO> getAllTransactions();
void deleteTransaction(UUID transactionId);
```

### 4. Update Frontend

**Old Response**:
```json
{
  "candidateId": "uuid",
  "email": "email@example.com",
  "success": true,
  "status": "CREATED"
}
```

**New Response**:
```json
{
  "transactionId": "uuid",
  "serviceName": "candidate-service",
  "operationType": "CREATE",
  "status": "SUCCESS",
  "entityId": "uuid",
  "correlationKey": "email@example.com",
  "createdAt": "2024-01-01T00:00:00Z",
  "processedAt": "2024-01-01T00:00:01Z"
}
```

## Error Handling

### 1. Transaction Not Found
```java
if (transaction == null) {
    throw new TransactionNotFoundException("Transaction not found");
}
```

### 2. Service Communication Failure
```java
try {
    transactionUpdateService.updateTransactionToSuccess(transactionId, entityId, response);
} catch (Exception e) {
    log.error("Failed to update transaction status", e);
    // Continue processing, transaction will be updated later
}
```

### 3. Retry Logic
```java
if (transaction.getRetryCount() < transaction.getMaxRetries()) {
    // Retry the operation
    transaction.setRetryCount(transaction.getRetryCount() + 1);
    transactionService.updateTransaction(transaction);
}
```

## Best Practices

### 1. Transaction ID Generation
- Always generate UUID for transaction ID
- Use correlation key (email) for easy lookup
- Include transaction ID in all Kafka messages

### 2. Status Updates
- Update to PROCESSING when starting
- Update to SUCCESS/FAILED when complete
- Include error messages for failures

### 3. Monitoring
- Set up alerts for failed transactions
- Monitor transaction processing times
- Track success/failure rates by service

### 4. Cleanup
- Implement TTL for old transactions
- Archive successful transactions
- Keep failed transactions for debugging

### 5. Code Organization
- Use common components from hcm-common
- Extend BaseTransactionConsumer for new consumers
- Keep service-specific logic minimal

## Future Enhancements

### 1. Transaction Chaining
- Support for multi-step transactions
- Parent-child transaction relationships
- Rollback capabilities

### 2. Advanced Monitoring
- Transaction metrics dashboard
- Performance analytics
- SLA monitoring

### 3. Integration
- Integration with external monitoring tools
- Webhook notifications
- Email alerts for failures

## Next Steps

### 1. Update Remaining Service Consumers
- Application Service Consumers
- Tenant Service Consumers
- Organization Service Consumers
- Job Requisition Service Consumers
- Position Service Consumers

### 2. Frontend Integration
- Update UI to use new transaction status endpoints
- Implement real-time transaction status updates
- Add transaction monitoring dashboard

### 3. Testing
- Comprehensive testing of transaction flow
- Load testing with high transaction volumes
- Error scenario testing

### 4. Monitoring Setup
- Implement monitoring and alerting
- Set up transaction metrics collection
- Configure automated cleanup processes 